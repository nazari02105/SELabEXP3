# SELabEXP3
| نام          | شماره دانشجویی|
| ------------- | ------------- |
| علیرضا عالیپناه                  | 99106396      |
| سیدمحمدیوسف نجفی      | 99102361      |
| علی نظری                        | 99102401      |

در این آزمایش در گام نخست باید پروژه 
library
داده شده را آماده اجرا می‌کردیم تا در ادامه ایرادهای آن را رفع کنیم و تست‌های مربوطه را هم برای آن بنویسیم.

در گام نخست یک پروژه جاوا ساخته شد و 
junit
به نیازمندی‌های آن اضافه شد:

<p align="center">
  <img src="./images/maven.png" />
</p>

سپس ساختار کلی پروژه‌ای که اشاره شده است را ایجاد می‌کنیم:

<p align="center">
  <img src="./images/structure.png" />
</p>

حال برای پیدا کردن خطاها، شروع به نوشتن تست می‌کنیم. اولین تست را برای تابع
lend book 
می‌نویسیم. تست نوشته شده به این شکل است:

<p align="center">
  <img src="./images/test1.png" />
</p>

در این تست دانشجو دوم در کتابخانه ثبتنام نکرده است و انتظار داشتیم که 
False
برگردانده شود ولی نتیجه تست به این شکل شد:

<p align="center">
  <img src="./images/result1.png" />
</p>

که همانطور که دیده می‌شود، انجام نشده است و اکسپشن پرتاب شده است که نادرست است.

حال تابع نام برده را به شکل زیر تغییر می‌دهیم تا این مشکل حل شود:

<p align="center">
  <img src="./images/code1.png" />
</p>

که خط 39 تا 41 جدید است و چک می‌کند دانشجو در کتابخانه هست یا نه و با این تغییر، نتیجه تست به شکل زیر می‌شود:

<p align="center">
  <img src="./images/result2.png" />
</p>

که همانطور که مشخص است، تست پاس شده است و مشکل برطرف شده است.

برای مشکل بعدی، برای 
return book 
تصمیم گرفتیم که تست بنویسیم که تست نوشته شده به شکل زیر است:

<p align="center">
  <img src="./images/test2.png" />
</p>

دی این سناریو یک دانشجو یک کتاب قرض می‌گیرد و تست می‌کنیم که کتاب را دانشجو داشته باشد بعدش و بعد از پس دادن کتاب هم انتظار داریم که دانشجو دیگر کتاب را نداشته باشد که بعد از ران به این نتیجه می‌رسیم:

<p align="center">
  <img src="./images/result3.png" />
</p>

که می‌بینیم مورد آخر ارور خورده است. کد را که چک کنیم می‌بینیم کتاب بعد از پس دادن از دارایی‌های دانشجو کم نمی‌شود. پس کد را به شکل زیر تغییر می‌دهیم:

<p align="center">
  <img src="./images/code2.png" />
</p>

که خط 65 جدید است. و بعد از این تغییر، نتیجه تست به شکل زیر می‌شود:

<p align="center">
  <img src="./images/result4.png" />
</p>

پس هر دو مشکل را با تست درآوردیم و حل کردیم.

برای گام بعد که پیاده‌سازی قابلیت سرچ است، در 
TDD
اصلی به این شکل بود که اول باید
compile error 
می‌خوردیم و بعد تازه کلاس‌ها و ... مورد نیاز را ایجاد می‌کردیم ولی در این حالت چون همه موارد از پیش آماده بوده است، امکان انجام این مرحله وجود ندارد و نخست تست‌هایی می‌نویسیم که ارور رانتایم بخورند و تکه تکه مشکلات را رفع می‌کنیم. 

برای سرچ کتاب، تست نوشته شده به شکل زیر است در درجه اول:

<p align="center">
  <img src="./images/test3.png" />
</p>

حال در درجه اول این تست را ران کنیم، نتیجه به شکل زیر می‌شود:

<p align="center">
  <img src="./images/result5.png" />
</p>

که منطقی هم هست چون پیاده‌سازی‌ای نداریم. حال مینیمال‌ترین پیاده‌سازی ممکن را انجام می‌دهیم که تست صرفا پاس شود که پیاده‌سازی به شکل زیر است:

<p align="center">
  <img src="./images/code3.png" />
</p>

ولی همانطور که انتظار می‌رود، این پیاده‌سازی درست نیست و یک تست دیگر می‌نویسیم که این مورد را نشان دهد:

<p align="center">
  <img src="./images/test4.png" />
</p>

که نتیجه ران شدن تست به شکل زیر است:

<p align="center">
  <img src="./images/result6.png" />
</p>

و می‌فهمیم پیاده‌سازی باید عوض شود که در نهایت پیاده‌سازی به شکل زیر می‌شود:

<p align="center">
  <img src="./images/code4.png" />
</p>

و با این کد هر دو تست به درستی ران می‌شود و پاس می‌شود:

<p align="center">
  <img src="./images/result7.png" />
</p>

ولی این کد می‌تواند ریفکتور شود و 
duplicate code
موجود است در آن و یکی از گام‌های 
TDD
هم همین مورد است و برای همین تست‌ها به شکل زیر می‌شود:

<p align="center">
  <img src="./images/test5.png" />
</p>

که بسیار بهتر شده است و دیگر
duplicate code
نداریم. به این ترتیب یک چرخه برای TDD انجام می‌شود.

دقیقا همین مراحل را برای سرچ دانشجو هم انجام می‌دهیم و صرفا عکس‌های آن را قرار می‌دهم و همه مرحله‌ها را دقیق نمی‌گذاریم زیرا دقیقا مانند سرچ کتاب است و مورد اضافه‌تر و جدیدتری ندارد.

<p align="center">
  <img src="./images/code5.png" />
</p>

<p align="center">
  <img src="./images/test6.png" />
</p>

 

<p align="center">
  <img src="./images/result8.png" />
</p>

و به این ترتیب این بخش از آزمایش کامل می‌شود.

</br></br></br></br>


پاسخ سوال 1:
</br>
در روش TDD ابتدا تست ها نوشته می شوند و سپس کد برنامه به گونه ای توسعه داده می شود تا تست ها پاس شوند.مزایا و معایب این روش شامل موارد زیر می باشد:
</br>
مزایا:
<ol>
	<li>این روش کمک می کند تا باگ ها در مراحل ابتدایی شناسایی شوند و برای پروژه هایی که در آن کیفیت کد حساسیت بالایی دارد کاربردی است.</li>
	<li>در روش های که توسعه به صورت incremental صورت می پذیرد،‌این امکان را می دهد تا پس از افزودن هر ویژگی، درستی عملکرد کد بررسی شده و از‌ آن اطمینان حاصل شود به همین دلیل مناسب این روش ها می باشد.</li>
	<li>از آنجایی که تست ها همیشه با کد  همگام هستند،‌نگهداری کد آسان شد و قابلیت بازنگری بالایی را فراهم می کند.</li>
</ol>
معایب:
<ol>
	<li>از آنجایی که نیاز است تا تست ها از ابتدا نوشته شوند،‌میتواند زمانبر باشد و برای پروژه های کوچک و سریع مناسب نباشد.</li>
	<li>می تواند برای تیم هایی که با این روش آشنایی ندارند پیچیده باشد و نیازمند آموزش و کسب تجربه باشد.</li>
</ol>
</br>
در روش سنتی ابتدا کد نوشته شده و سپس برای آن تست ها نوشته می شوند.
</br>
مزایا:
<ol>
	<li>از آنجایی که امکان نوشتن کد با سرعت بالا و از همان ابتدا را فراهم می کند می تواند برای پروژه های کوچک و سریع مناسب باشد.</li>
	<li>پروژه هایی که در آن ها تغییرات کم بوده و توسعه دهنده به خوبی با ویژگی ها و ابعاد پروژه آشنایی دارد می تواند مناسب باشد.</li>
</ol>
معیاب:
<ol>
	<li>از آنجایی که ممکن است باگ ها دیر شناسایی شوند، یافتن و رفع آن ها می تواند هزینه بر باشد.</li>
	<li>از آنجایی که تست ها بعد از پیاده سازی کد نوشته می شوند،‌ممکن است تمام جنبه ها را در نظر نگیرند و کیفیت کد آسیب ببیند.</li>
	<li>بازنگری در کد ممکن است سخت تر شود زیرا پس از ایجاد تغییرات ممکن است نیاز به تغییرات بیشتری باشد.</li>
</ol>
در نهایت می توان نتیجه گرفت که TDD برای پروژه هایی که در آن ها کیفیت کد اهمیت بسازایی دارد و همچنین توسعه به صورت تدریجی صورت می گیرد مناسب است در حالی که روش سنتی برای پروژه های کوچک و سریع کارایی دارد.
</br>
</br>
سوال 2:
</br>
تیم توسعه با دانشی که از کد دارد،‌ از درستی بخش های کد و ماژول ها و همچنین تعاملات صحیح بین آن ها اطمینان حاصل می کند در حالی که تیم تضمین کیفیت با دید کلی تری بررسی می کند و از عملکرد نرم افزار به عنوان یک سیستم کامل و توانایی آن در برآورده کردن نیاز های کاربر نهایی را مورد بررسی قرار می دهد.
</br>
تیم توسعه بیشتر با دسته های آزمون زیر سر و کار دارد:
</br>
تست واحد: این تست برای کوچکترین قطعات کد مانند توابع و متد ها انجام می شود تا از صحت کارایی آن ها اطمینان حاصل شود. توسعه دهندگان با نوشتن این تست ها از عملکرد صحیح کدشان اطمینان حاصل کرد و باگ های اولیه را شناسایی می کنند.
</br>
تست یکپارچگی: در این روش تعامل بین بخش های مختلف یک سیستم تست می شوند تا از درستی این تعاملات اطمینان حاصل شود. توسعه دهندگان این تست ها را انجام میدهند تا تعامل ماژول های مختلف با یکدیگر را بررسی کرده و از کارآیی و صحت این تعامل اطمینان حاصل کنند.
</br>
تست رگرسیون: این تست بررسی می کند تا تغییرات جدید کد، عملکرد بخش های قبلی را تحت تاثیر قرار ندهد. این تست به توسعه دهندگان این امکان را می دهد که باگ هایی که از اضافه شدن تغییرات جدید در کد ایجاد شده اند را شناسایی و رفع کنند.
</br>
تیم کیفیت بیشتر با دسته های آزمون زیر سر و کار دارد:
</br>
تست کارکردی: این تست بررسی میکند که آیا نرم افزار توسعه داده شده با نیازمندی عملکردی تعریف شده تطابق دارد. تیم کیفیت اطمینان حاصل می کند تا نرم افزار تمامی نیازمندی هایی که مستندات و کاربران تعریف کرده اند را برآورده می کند.
</br>
تست سیستم: این تست عملکرد نرم افزار را به عنوان یک سیستم کامل و یکپارچه بررسی می کند. تیم کیفیت بررسی میکند که آیا نرم افزار به عنوان یک سیستم کامل به درستی عمل می کند و آیا همه ماژول ها به دررستی کار میکنند.
</br>
تست پذیرش: این روش از تست بررسی میکند که آیا نرم افزار تولید شده نیازمندی های کاربر نهایی و مشتری ها را برآورده می کند. در واقع تیم تضمین کیفیت بررسی می کند که آیا نرم افزار برای ارائه به مشتری آماده می باشد یا خیر.
</br>
تست کارآیی: این تست وظیفه ارزیابی سرعت، پاسخگویی، پایداری و مقیاس‌پذیری نرم‌افزار تحت بارهای مختلف را دارد. تیم تضمین کیفیت با انجام این تست ها از عملکرد بهینه نرم افزار در شرایط مختلف اطمینان حاصل می کند.

</br></br></br></br>


حال به این می‌پردازیم که از ابزار های تست برای بررسی دقیق کاورج استفاده کنیم. پروژه ی json-simple که به ما ارائه شده بود را با استفاده از ide intellij و  maven configuration آن را باز میکنیم:
![image](https://github.com/user-attachments/assets/2da1dce0-5b7a-4db2-9b40-0192d2a64644)

سپس فایل TestJson.java را باز میکنیم و Run test with coverage را اعمال می‌کنیم.
![image](https://github.com/user-attachments/assets/16f05dd3-8d4d-49bc-9be4-004f32a52c9f)

نتیجه به شکل زیر می‌باشد می‌بینیم که در کنار هر فایل در سمت چپ درصد کاورج متد ها، کلاس ها و خط ها آمده است.
![image](https://github.com/user-attachments/assets/19efe06f-2367-4cbd-89ea-c623b9186898)

حال به طور خاص برای یکی از متد های تست، چک پوینت می‌گذاریم تا روند debug و تست آن را مشاهده کنیم.
![image](https://github.com/user-attachments/assets/8bf3933c-0b89-495d-b4a8-bb08b93daba3)

مواردی که این کلاس تست کرده است را می‌بینیم:
![image](https://github.com/user-attachments/assets/a4234217-0e96-4d09-bf66-8e94e1aed237)

حال Generate Coverage Report را میزنیم که یک فایل html به ما خروجی میدهد:
![image](https://github.com/user-attachments/assets/5c56209a-82fd-47ac-947c-69e10bd4c00f)
که این فایل html مذکور می‌باشد:
![image](https://github.com/user-attachments/assets/bf82f1ff-244b-4694-a878-0dba32b5747d)

اینجا می‌بینیم که با کلیک بر روی لینک هر یک از فایل های گزارش، خطوط کاور شده سبز رنگ هستند و خطوط کاور نشده قرمز رنگ هستند:
![image](https://github.com/user-attachments/assets/2a4b8fc6-4388-4491-87ae-6350ec1555e1)

که اینجا بررسی پروژه json-simple به پایان می‌رسد.

حال به بررسی پروژه Library می‌پردازیم به همین شکل:
ابتدا پروژه را با Intellij باز می‌کنیم:
![image](https://github.com/user-attachments/assets/17b941b3-2d3e-48d1-992e-3e3515967362)
حال هر کدام از فایل های تست را Run test with coverage می‌گیریم، نتایج را در زیر مشاهده می‌کنید:
![image](https://github.com/user-attachments/assets/22460a20-a975-4c7b-9055-ca797457c81b)

![image](https://github.com/user-attachments/assets/4819ec94-2eea-49e6-bbcc-31636212f357)

و به همان ترتیبی که در پروژه قبلی نیز دیدیم میتوانیم Generate coverage Report نیز انجام دهیم و خطوط کاور شده و کاور نشده را در قالب یک فایل html ببینیم.
حال به این میپردازیم که چند تست به تست ها اضافه کنیم که کاورج تست ها بالا رود:
کاورج با تست های اولیه به این صورت است:
![image](https://github.com/user-attachments/assets/1c75a8aa-91c5-4958-a6ad-94b63ce2b114)

این تست ها را برای تابع LendBook در Library اضافه میکنیم:
![image](https://github.com/user-attachments/assets/2b5692ec-32a5-4c46-ba69-508a52d9459f)

و نتیجه آن ها موفقیت آمیز است و پاس می شوند، همچنین درصد کاورج کلاس Library نیز بالا رفته:
![image](https://github.com/user-attachments/assets/83e7f92b-4b3a-4135-9044-f31b383597f4)


![image](https://github.com/user-attachments/assets/0da59322-94a8-4b1a-a2f5-6cf2f639d933)

حال تعدادی تست دیگر نیز اضافه میکنیم و نتیجه نهایی را قرار می‌دهیم:

![image](https://github.com/user-attachments/assets/d52dfc92-a6c3-46c8-8963-145791599853)

می‌بینیم که تست ها پاس شده اند و کاورج نهایی نیز به طرز چشمگیری افزایش داشته:
![image](https://github.com/user-attachments/assets/157b25fa-46a7-464b-b959-e2014b1f3d6e)


و این بخش نیز به پایان رسید.